@cindex elementary functions
@cindex mathematical functions, elementary

@menu
* Mathematical Constants::
* Mathematical function implementation scope::
* Parametrized function types::
@end menu

@node Mathematical Constants
@section Mathematical Constants
@cindex mathematical constants

The name scheme used in the GSL for the mathematical constants
deviates from GSL conventions, by using macros having the prefix 
@code{M_}. In FGSL, the same naming scheme is used, but the constants
are Fortran entities with the @code{PARAMETER} attribute. 

@node Mathematical function implementation scope
@section Mathematical function implementation scope
@cindex Mathematical function implementation scope

Of the mathematical functions, only those are interfaced which do 
not map to a Fortran intrinsic:
@itemize
@item @code{fgsl_isnan, fgsl_isinf, fgsl_finite}
@item @code{fgsl_log1p, fgsl_expm1, fgsl_ldexp, fgsl_frexp}
@item @code{fgsl_hypot, fgsl_acosh, fgsl_asinh, fgsl_atanh}
@item @code{fgsl_fcmp}
@end itemize

@node  Parametrized function types
@section Parametrized function types
@cindex Parametrized function types

The components of the GSL types @code{fgsl_function} and
@code{fgsl_function_fdf} are not directly accessible from
Fortran. Hence the following constructors are provided:
@verbatiminclude codefrags/math_1.f90
@verbatiminclude codefrags/math_2.f90
@noindent
The user-implemented function and - if required - its derivative 
must use a C interoperable interface (@code{use, intrinsic ::
iso_c_binding}):
@verbatiminclude codefrags/math_3.f90
@verbatiminclude codefrags/math_4.f90
@noindent For evaluation of the function, or its derivative, or both
the function and its derivative the following routines are provided:
@example
  real(fgsl_double) function fgsl_fn_eval(sfunc, x)
    type(fgsl_function), intent(inout) :: sfunc
    real(fgsl_double), intent(in) :: x
  end function fgsl_fn_eval
  real(fgsl_double) fgsl_fn_fdf_eval_f(sfunc, x)
    type(fgsl_function_fdf), intent(inout) :: sfunc
    real(fgsl_double), intent(in) :: x
  end function fgsl_fn_fdf_eval_f
  real(fgsl_double) function fgsl_fn_fdf_eval_df(sfunc, x)
    type(fgsl_function_fdf), intent(inout) :: sfunc
    real(fgsl_double), intent(in) :: x
  end function fgsl_fn_fdf_eval_df
  subroutine fgsl_fn_fdf_eval_f_df(sfunc, x, y, dy)
    type(fgsl_function_fdf), intent(inout) :: sfunc
    real(fgsl_double), intent(in) :: x
    real(fgsl_double), intent(out) :: y, dy
  end subroutine fgsl_fn_fdf_eval_f_df
@end example
@noindent
The function objects can be deallocated via the
@code{fgsl_function_free} and @code{fgsl_function_fdf_free} subroutine
calls, which take the appropriate object as their only argument.
